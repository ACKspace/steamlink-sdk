From 13d7c4115d1dfb43c0745fb165bda03af4d9e5ba Mon Sep 17 00:00:00 2001
From: Garrett Brown <themagnificentmrb@gmail.com>
Date: Fri, 28 Oct 2016 13:50:22 -0700
Subject: [PATCH] Add Steam Link support

---
 configure.ac                                       |  19 +-
 system/addon-manifest.xml                          |   1 -
 tools/depends/.gitignore                           |   1 +
 tools/depends/target/Makefile                      |  72 ++--
 tools/depends/target/ffmpeg/Makefile               |   2 +-
 tools/depends/target/libsdl2/Makefile              |   2 +-
 tools/depends/target/openssl/Makefile              |   2 +-
 tools/depends/target/zlib/Makefile                 |   2 +-
 xbmc/cores/AudioEngine/AESinkFactory.cpp           |  25 ++
 xbmc/cores/AudioEngine/Makefile.in                 |   3 +
 xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.cpp   | 259 +++++++++++++
 xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.h     |  81 ++++
 .../VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp      |   7 +-
 xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in |   4 +
 .../VideoPlayer/DVDCodecs/Video/SteamLinkVideo.cpp | 405 ++++++++++++++++++++
 .../VideoPlayer/DVDCodecs/Video/SteamLinkVideo.h   |  85 ++++
 xbmc/cores/VideoPlayer/VideoRenderers/Makefile.in  |   4 +
 .../VideoPlayer/VideoRenderers/RenderFormats.h     |   1 +
 .../VideoPlayer/VideoRenderers/RenderManager.cpp   |   8 +-
 .../VideoRenderers/SteamLinkRenderer.cpp           |  39 ++
 .../VideoPlayer/VideoRenderers/SteamLinkRenderer.h |  49 +++
 xbmc/windowing/WinEventsSDL.cpp                    | 426 ++++++++++++++++++++-
 xbmc/windowing/WinEventsSDL.h                      |   2 +-
 xbmc/windowing/egl/EGLNativeTypeSDL.cpp            | 161 ++++++++
 xbmc/windowing/egl/EGLNativeTypeSDL.h              |  60 +++
 xbmc/windowing/egl/EGLWrapper.cpp                  |   5 +
 xbmc/windowing/egl/Makefile.in                     |   1 +
 27 files changed, 1672 insertions(+), 54 deletions(-)
 create mode 100644 xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.cpp
 create mode 100644 xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.h
 create mode 100644 xbmc/cores/VideoPlayer/DVDCodecs/Video/SteamLinkVideo.cpp
 create mode 100644 xbmc/cores/VideoPlayer/DVDCodecs/Video/SteamLinkVideo.h
 create mode 100644 xbmc/cores/VideoPlayer/VideoRenderers/SteamLinkRenderer.cpp
 create mode 100644 xbmc/cores/VideoPlayer/VideoRenderers/SteamLinkRenderer.h
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeSDL.cpp
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeSDL.h

diff --git a/configure.ac b/configure.ac
index 9b8b889..8b47d90 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1197,6 +1197,13 @@ if test "x$use_dbus" != "xno"; then
 else
   AC_MSG_NOTICE($dbus_disabled)
 fi
+  #case "$host_vendor" != "apple"; determine availability of SDL or SDL2
+  PKG_CHECK_MODULES([SDL2], [sdl2],
+    [AC_DEFINE([HAVE_SDL_VERSION],[2],["SDL major version"])
+     AC_DEFINE([HAVE_SDL],[1],["Define to 1 if using sdl"])
+     INCLUDES="$INCLUDES $SDL2_CFLAGS"; LIBS="$LIBS $SDL2_LIBS"],
+     AC_MSG_RESULT("SDL enabled")
+  )
 fi
 
 XB_FIND_SONAME([ASS],         [ass])
@@ -1225,6 +1232,16 @@ else
   AC_MSG_RESULT($alsa_disabled)
 fi
 
+# Steam Link
+AC_CHECK_HEADERS([SLVideo.h SLAudio.h], steamlink_found=yes,)
+if test "$steamlink_found" = "yes"; then
+  USE_STEAMLINK=1
+  use_pulse=no
+  AC_DEFINE([HAS_STEAMLINK], [], [Define if we are compiling with the Steam Link SDK])
+  LIBS="$LIBS -lSLVideo -lSLAudio"
+fi
+AC_SUBST(USE_STEAMLINK)
+
 # PulseAudio
 if test "x$use_pulse" != "xno"; then
   if test "$host_vendor" = "apple" ; then
@@ -1615,7 +1632,7 @@ fi
 
 if test "${USE_STATIC_FFMPEG}" = "1"; then
   # get the libdir for static linking
-  FFMPEG_LIBDIR=${pkg_cfg_prefix}$(PKG_CONFIG_SYSROOT_DIR="" ${PKG_CONFIG} --static --variable=libdir libavcodec)
+  FFMPEG_LIBDIR=$(${PKG_CONFIG} --static --variable=libdir libavcodec)
   GNUTLS_ALL_LIBS=$(${PKG_CONFIG} --static --libs-only-l --silence-errors gnutls)
 
   # check if static libs are available
diff --git a/system/addon-manifest.xml b/system/addon-manifest.xml
index 04cce30..dff21e9 100644
--- a/system/addon-manifest.xml
+++ b/system/addon-manifest.xml
@@ -28,7 +28,6 @@
   <addon>screensaver.xbmc.builtin.black</addon>
   <addon>screensaver.xbmc.builtin.dim</addon>
   <addon>script.module.pil</addon>
-  <addon>service.xbmc.versioncheck</addon>
   <addon>skin.estuary</addon>
   <addon>skin.estouchy</addon>
   <addon>webinterface.default</addon>
diff --git a/tools/depends/.gitignore b/tools/depends/.gitignore
index c6c4d25..339a459 100644
--- a/tools/depends/.gitignore
+++ b/tools/depends/.gitignore
@@ -18,6 +18,7 @@
 /target/*/arm-linux-gnueabihf/*
 /target/*/arm-linux-androideabi-*/*
 /target/*/arm-linux-gnueabi/*
+/target/*/armv7a-cros-linux-gnueabi/*
 /target/*/macosx*.*_x86_64-target/
 /target/*/macosx*.*_x86_64-target/*
 /target/*/macosx*.*_i386-target/
diff --git a/tools/depends/target/Makefile b/tools/depends/target/Makefile
index f0f0bf4..9378623 100644
--- a/tools/depends/target/Makefile
+++ b/tools/depends/target/Makefile
@@ -130,41 +130,41 @@ distclean::
 	for d in $(DEPENDS); do $(MAKE) -C $$d distclean; done
 
 linux-system-libs-egl:
-	[ -f $(PREFIX)/lib/pkgconfig/egl.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/egl.pc $(PREFIX)/lib/pkgconfig/egl.pc
-	[ -f $(PREFIX)/lib/pkgconfig/damageproto.pc ] || ln -sf  /usr/share/pkgconfig/damageproto.pc $(PREFIX)/lib/pkgconfig/damageproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/fixesproto.pc ] || ln -sf  /usr/share/pkgconfig/fixesproto.pc $(PREFIX)/lib/pkgconfig/fixesproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/x11-xcb.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/x11-xcb.pc $(PREFIX)/lib/pkgconfig/x11-xcb.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-dri2.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-dri2.pc $(PREFIX)/lib/pkgconfig/xcb-dri2.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-dri3.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-dri3.pc $(PREFIX)/lib/pkgconfig/xcb-dri3.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-glx.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-glx.pc $(PREFIX)/lib/pkgconfig/xcb-glx.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-xfixes.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-xfixes.pc $(PREFIX)/lib/pkgconfig/xcb-xfixes.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-present.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-present.pc $(PREFIX)/lib/pkgconfig/xcb-present.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-randr.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xcb-randr.pc $(PREFIX)/lib/pkgconfig/xcb-randr.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-render.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xcb-render.pc $(PREFIX)/lib/pkgconfig/xcb-render.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-shape.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-shape.pc $(PREFIX)/lib/pkgconfig/xcb-shape.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-sync.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-sync.pc $(PREFIX)/lib/pkgconfig/xcb-sync.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xdamage.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xdamage.pc $(PREFIX)/lib/pkgconfig/xdamage.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xf86vidmodeproto.pc ] || ln -sf /usr/share/pkgconfig/xf86vidmodeproto.pc $(PREFIX)/lib/pkgconfig/xf86vidmodeproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xfixes.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xfixes.pc $(PREFIX)/lib/pkgconfig/xfixes.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xshmfence.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xshmfence.pc $(PREFIX)/lib/pkgconfig/xshmfence.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xxf86vm.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xxf86vm.pc $(PREFIX)/lib/pkgconfig/xxf86vm.pc
+	[ -L $(PREFIX)/lib/pkgconfig/egl.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/egl.pc $(PREFIX)/lib/pkgconfig/egl.pc
+	[ -L $(PREFIX)/lib/pkgconfig/damageproto.pc ] || ln -sf  /usr/share/pkgconfig/damageproto.pc $(PREFIX)/lib/pkgconfig/damageproto.pc
+	[ -L $(PREFIX)/lib/pkgconfig/fixesproto.pc ] || ln -sf  /usr/share/pkgconfig/fixesproto.pc $(PREFIX)/lib/pkgconfig/fixesproto.pc
+	[ -L $(PREFIX)/lib/pkgconfig/x11-xcb.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/x11-xcb.pc $(PREFIX)/lib/pkgconfig/x11-xcb.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xcb-dri2.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-dri2.pc $(PREFIX)/lib/pkgconfig/xcb-dri2.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xcb-dri3.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-dri3.pc $(PREFIX)/lib/pkgconfig/xcb-dri3.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xcb-glx.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-glx.pc $(PREFIX)/lib/pkgconfig/xcb-glx.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xcb-xfixes.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-xfixes.pc $(PREFIX)/lib/pkgconfig/xcb-xfixes.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xcb-present.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-present.pc $(PREFIX)/lib/pkgconfig/xcb-present.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xcb-randr.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xcb-randr.pc $(PREFIX)/lib/pkgconfig/xcb-randr.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xcb-render.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xcb-render.pc $(PREFIX)/lib/pkgconfig/xcb-render.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xcb-shape.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-shape.pc $(PREFIX)/lib/pkgconfig/xcb-shape.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xcb-sync.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-sync.pc $(PREFIX)/lib/pkgconfig/xcb-sync.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xdamage.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xdamage.pc $(PREFIX)/lib/pkgconfig/xdamage.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xf86vidmodeproto.pc ] || ln -sf /usr/share/pkgconfig/xf86vidmodeproto.pc $(PREFIX)/lib/pkgconfig/xf86vidmodeproto.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xfixes.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xfixes.pc $(PREFIX)/lib/pkgconfig/xfixes.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xshmfence.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xshmfence.pc $(PREFIX)/lib/pkgconfig/xshmfence.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xxf86vm.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xxf86vm.pc $(PREFIX)/lib/pkgconfig/xxf86vm.pc
 
 linux-system-libs: linux-system-libs-egl
-	[ -f $(PREFIX)/lib/pkgconfig/x11.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/x11.pc $(PREFIX)/lib/pkgconfig/x11.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xproto.pc ] || ln -sf /usr/share/pkgconfig/xproto.pc $(PREFIX)/lib/pkgconfig/xproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/kbproto.pc ] || ln -sf /usr/share/pkgconfig/kbproto.pc $(PREFIX)/lib/pkgconfig/kbproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xcb.pc $(PREFIX)/lib/pkgconfig/xcb.pc
-	[ -f $(PREFIX)/lib/pkgconfig/pthread-stubs.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/pthread-stubs.pc $(PREFIX)/lib/pkgconfig/pthread-stubs.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xau.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xau.pc $(PREFIX)/lib/pkgconfig/xau.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xdmcp.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xdmcp.pc $(PREFIX)/lib/pkgconfig/xdmcp.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xext.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xext.pc $(PREFIX)/lib/pkgconfig/xext.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xextproto.pc ] || ln -sf /usr/share/pkgconfig/xextproto.pc $(PREFIX)/lib/pkgconfig/xextproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xrandr.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xrandr.pc $(PREFIX)/lib/pkgconfig/xrandr.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xrender.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xrender.pc $(PREFIX)/lib/pkgconfig/xrender.pc
-	[ -f $(PREFIX)/lib/pkgconfig/randrproto.pc ] || ln -sf /usr/share/pkgconfig/randrproto.pc $(PREFIX)/lib/pkgconfig/randrproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/renderproto.pc ] || ln -sf /usr/share/pkgconfig/renderproto.pc $(PREFIX)/lib/pkgconfig/renderproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xt.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xt.pc $(PREFIX)/lib/pkgconfig/xt.pc
-	[ -f $(PREFIX)/lib/pkgconfig/ice.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/ice.pc $(PREFIX)/lib/pkgconfig/ice.pc
-	[ -f $(PREFIX)/lib/pkgconfig/sm.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/sm.pc $(PREFIX)/lib/pkgconfig/sm.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xmu.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xmu.pc $(PREFIX)/lib/pkgconfig/xmu.pc
-	[ -f $(PREFIX)/lib/pkgconfig/libdrm.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/libdrm.pc $(PREFIX)/lib/pkgconfig/libdrm.pc
+	[ -L $(PREFIX)/lib/pkgconfig/x11.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/x11.pc $(PREFIX)/lib/pkgconfig/x11.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xproto.pc ] || ln -sf /usr/share/pkgconfig/xproto.pc $(PREFIX)/lib/pkgconfig/xproto.pc
+	[ -L $(PREFIX)/lib/pkgconfig/kbproto.pc ] || ln -sf /usr/share/pkgconfig/kbproto.pc $(PREFIX)/lib/pkgconfig/kbproto.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xcb.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xcb.pc $(PREFIX)/lib/pkgconfig/xcb.pc
+	[ -L $(PREFIX)/lib/pkgconfig/pthread-stubs.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/pthread-stubs.pc $(PREFIX)/lib/pkgconfig/pthread-stubs.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xau.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xau.pc $(PREFIX)/lib/pkgconfig/xau.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xdmcp.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xdmcp.pc $(PREFIX)/lib/pkgconfig/xdmcp.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xext.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xext.pc $(PREFIX)/lib/pkgconfig/xext.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xextproto.pc ] || ln -sf /usr/share/pkgconfig/xextproto.pc $(PREFIX)/lib/pkgconfig/xextproto.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xrandr.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xrandr.pc $(PREFIX)/lib/pkgconfig/xrandr.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xrender.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xrender.pc $(PREFIX)/lib/pkgconfig/xrender.pc
+	[ -L $(PREFIX)/lib/pkgconfig/randrproto.pc ] || ln -sf /usr/share/pkgconfig/randrproto.pc $(PREFIX)/lib/pkgconfig/randrproto.pc
+	[ -L $(PREFIX)/lib/pkgconfig/renderproto.pc ] || ln -sf /usr/share/pkgconfig/renderproto.pc $(PREFIX)/lib/pkgconfig/renderproto.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xt.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xt.pc $(PREFIX)/lib/pkgconfig/xt.pc
+	[ -L $(PREFIX)/lib/pkgconfig/ice.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/ice.pc $(PREFIX)/lib/pkgconfig/ice.pc
+	[ -L $(PREFIX)/lib/pkgconfig/sm.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/sm.pc $(PREFIX)/lib/pkgconfig/sm.pc
+	[ -L $(PREFIX)/lib/pkgconfig/xmu.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xmu.pc $(PREFIX)/lib/pkgconfig/xmu.pc
+	[ -L $(PREFIX)/lib/pkgconfig/libdrm.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/libdrm.pc $(PREFIX)/lib/pkgconfig/libdrm.pc
diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index eaf9fc4..8dfbb48 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -8,7 +8,7 @@ APPLY_PATCHES=no
 
 # configuration settings
 ffmpg_config = --prefix=$(PREFIX) --extra-version="kodi-$(VERSION)"
-ffmpg_config += --cc=$(CC) --cxx=$(CXX) --ar=$(AR) --ranlib=$(RANLIB)
+ffmpg_config += --cc="$(CC)" --cxx="$(CXX)" --ar=$(AR) --ranlib=$(RANLIB)
 ffmpg_config += --disable-devices --disable-doc
 ffmpg_config += --disable-ffplay --disable-ffmpeg --disable-sdl
 ffmpg_config += --disable-ffprobe --disable-ffserver
diff --git a/tools/depends/target/libsdl2/Makefile b/tools/depends/target/libsdl2/Makefile
index 6c6eb5a..4c88e60 100644
--- a/tools/depends/target/libsdl2/Makefile
+++ b/tools/depends/target/libsdl2/Makefile
@@ -8,7 +8,7 @@ SOURCE=$(LIBNAME)-$(VERSION)
 ARCHIVE=$(SOURCE).tar.gz
 
 # configuration settings
-CONFIGURE=./configure --prefix=$(PREFIX) --disable-video-directfb
+CONFIGURE=./configure --prefix=$(PREFIX) --disable-video-directfb --without-x --disable-video-x11
 ifneq ($(OS),linux)
 CONFIGURE += --without-x --disable-video-x11
 endif
diff --git a/tools/depends/target/openssl/Makefile b/tools/depends/target/openssl/Makefile
index def0525..dcae452 100644
--- a/tools/depends/target/openssl/Makefile
+++ b/tools/depends/target/openssl/Makefile
@@ -33,7 +33,7 @@ $(TARBALLS_LOCATION)/$(ARCHIVE):
 $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	rm -rf $(PLATFORM); mkdir -p $(PLATFORM)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
-	cd $(PLATFORM); AR="$(AR)" CFLAGS="$(CFLAGS)" CC=$(CC) RANLIB=$(RANLIB) $(CONFIGURE)
+	cd $(PLATFORM); AR="$(AR)" CFLAGS="$(CFLAGS)" CC="$(CC)" RANLIB=$(RANLIB) $(CONFIGURE)
 	if test "$(OS)" = "osx"; then \
 		sed -ie "s|CC= /usr/bin/gcc-4.2|CC= $(CC)|" "$(PLATFORM)/Makefile"; \
 		sed -ie "s|CFLAG= |CFLAG=$(CFLAGS) |" "$(PLATFORM)/Makefile"; \
diff --git a/tools/depends/target/zlib/Makefile b/tools/depends/target/zlib/Makefile
index 551301c..2145116 100644
--- a/tools/depends/target/zlib/Makefile
+++ b/tools/depends/target/zlib/Makefile
@@ -7,7 +7,7 @@ VERSION=1.2.7
 SOURCE=$(LIBNAME)-$(VERSION)
 ARCHIVE=$(SOURCE).tar.gz
 # configuration settings
-CONFIGURE= CC="$(CC)" CFLAGS="$(CFLAGS)" ./configure --prefix=$(PREFIX) --static
+CONFIGURE= CC="$(CC)" CFLAGS="$(CFLAGS) -fPIC" ./configure --prefix=$(PREFIX) --static
 
 LIBDYLIB=$(PLATFORM)/$(LIBNAME).a
 
diff --git a/xbmc/cores/AudioEngine/AESinkFactory.cpp b/xbmc/cores/AudioEngine/AESinkFactory.cpp
index 952461d..4ebed1f 100644
--- a/xbmc/cores/AudioEngine/AESinkFactory.cpp
+++ b/xbmc/cores/AudioEngine/AESinkFactory.cpp
@@ -42,6 +42,9 @@
   #if defined(HAS_PULSEAUDIO)
     #include "Sinks/AESinkPULSE.h"
   #endif
+  #if defined(HAS_STEAMLINK)
+    #include "Sinks/AESinkSteamLink.h"
+  #endif
 #else
   #pragma message("NOTICE: No audio sink for target platform.  Audio output will not be available.")
 #endif
@@ -83,6 +86,9 @@ void CAESinkFactory::ParseDevice(std::string &device, std::string &driver)
   #if defined(HAS_PULSEAUDIO)
         driver == "PULSE"       ||
   #endif
+  #if defined(HAS_STEAMLINK)
+        driver == "STEAMLINK"   ||
+  #endif
 #endif
         driver == "PROFILER"    ||
         driver == "NULL")
@@ -133,6 +139,10 @@ IAESink *CAESinkFactory::TrySink(std::string &driver, std::string &device, AEAud
     if (driver == "OSS")
       sink = new CAESinkOSS();
  #endif
+ #if defined(HAS_STEAMLINK)
+   if (driver == "STEAMLINK")
+     sink = new STEAMLINK::CAESinkSteamLink();
+ #endif
 #endif
   }
 
@@ -250,6 +260,10 @@ void CAESinkFactory::EnumerateEx(AESinkInfoList &list, bool force)
     if (envSink == "OSS")
       CAESinkOSS::EnumerateDevicesEx(info.m_deviceInfoList, force);
     #endif
+    #if defined(HAS_STEAMLINK)
+    if (envSink == "STEAMLINK")
+      STEAMLINK::CAESinkSteamLink::EnumerateDevicesEx(info.m_deviceInfoList, force);
+    #endif
 
     if(!info.m_deviceInfoList.empty())
     {
@@ -290,6 +304,17 @@ void CAESinkFactory::EnumerateEx(AESinkInfoList &list, bool force)
     list.push_back(info);
   #endif
 
+  #if defined(HAS_STEAMLINK)
+  info.m_deviceInfoList.clear();
+  info.m_sinkName = "STEAMLINK";
+  STEAMLINK::CAESinkSteamLink::EnumerateDevicesEx(info.m_deviceInfoList, force);
+  if(!info.m_deviceInfoList.empty())
+  {
+    list.push_back(info);
+    return;
+  }
+  #endif
+
 #endif
 
 }
diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index 9a4e998..183f10e 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -63,6 +63,9 @@ SRCS += Sinks/AESinkOSS.cpp
 ifeq (@USE_PULSE@,1)
 SRCS += Sinks/AESinkPULSE.cpp
 endif
+ifeq (@USE_STEAMLINK@,1)
+SRCS += Sinks/AESinkSteamLink.cpp
+endif
 endif
 
 SRCS += Engines/ActiveAE/AudioDSPAddons/ActiveAEDSP.cpp
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.cpp
new file mode 100644
index 0000000..906e0ff
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.cpp
@@ -0,0 +1,259 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      Copyright (C) 2016 Valve Corporation
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "AESinkSteamLink.h"
+#include "cores/AudioEngine/Utils/AEUtil.h"
+#include "utils/log.h"
+#include "utils/TimeUtils.h"
+
+// Steam Link audio API
+#include "SLAudio.h"
+
+#include <cstring>
+#include <unistd.h>
+
+#define SL_SAMPLE_RATE  48000
+#define SINK_FEED_MS    50 // Steam Link game streaming uses 10ms
+#define CACHE_TOTAL_MS  200
+#define INITIAL_ATTENUATION_TIME 6.0
+#define DELAY_OFFSET_SECONDS -0.025
+
+using namespace STEAMLINK;
+
+namespace STEAMLINK
+{
+  extern uint32_t g_unQueuedVideoMS;
+}
+
+namespace
+{
+  void LogFunction(void *pContext, ESLAudioLog eLogLevel, const char *pszMessage)
+  {
+    switch (eLogLevel)
+    {
+    case k_ESLAudioLogDebug:
+      CLog::Log(LOGDEBUG, "%s", pszMessage);
+      break;
+    case k_ESLAudioLogInfo:
+      CLog::Log(LOGINFO, "%s", pszMessage);
+      break;
+    case k_ESLAudioLogWarning:
+      CLog::Log(LOGWARNING, "%s", pszMessage);
+      break;
+    case k_ESLAudioLogError:
+      CLog::Log(LOGERROR, "%s", pszMessage);
+      break;
+    default:
+      break;
+    }
+  }
+}
+
+CAESinkSteamLink::CAESinkSteamLink() :
+  m_lastPackageStamp(0.0),
+  m_delaySec(0.0),
+  m_context(nullptr),
+  m_stream(nullptr)
+{
+  SLAudio_SetLogLevel(k_ESLAudioLogDebug);
+  SLAudio_SetLogFunction(LogFunction, nullptr);
+}
+
+CAESinkSteamLink::~CAESinkSteamLink()
+{
+  Deinitialize();
+  SLAudio_SetLogFunction(nullptr, nullptr);
+}
+
+bool CAESinkSteamLink::Initialize(AEAudioFormat &format, std::string &device)
+{
+  Deinitialize();
+
+  m_initialAttenuation = true;
+  m_startTime = (double)CurrentHostCounter() / CurrentHostFrequency();
+  
+  format.m_dataFormat    = AE_FMT_S16NE;
+  format.m_sampleRate    = SL_SAMPLE_RATE;
+  format.m_frames        = format.m_sampleRate * SINK_FEED_MS / 1000;
+  format.m_frameSize     = format.m_channelLayout.Count() * (CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3);
+  m_format = format;
+
+  CSLAudioContext* context = SLAudio_CreateContext();
+  if (context)
+  {
+    CSLAudioStream* stream = SLAudio_CreateStream(context, m_format.m_sampleRate, m_format.m_channelLayout.Count(), format.m_frames * format.m_frameSize, false);
+    if (stream)
+    {
+      // Success
+      m_context = context;
+      m_stream = stream;
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "SteamLinkAudio: Failed to create stream");
+      SLAudio_FreeContext(context);
+    }
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "SteamLinkAudio: Failed to create context");
+  }
+
+  return m_context != nullptr;
+}
+
+void CAESinkSteamLink::Deinitialize()
+{
+  while (m_AudioQueue.size() > 0)
+  {
+    delete[] m_AudioQueue.front().m_pData;
+    m_AudioQueue.pop();
+  }
+  if (m_stream)
+  {
+    SLAudio_FreeStream(m_stream);
+    m_stream = nullptr;
+  }
+  if (m_context)
+  {
+    SLAudio_FreeContext(m_context);
+    m_context = nullptr;
+  }
+}
+
+double CAESinkSteamLink::GetCacheTotal()
+{
+  return CACHE_TOTAL_MS / 1000.0;
+}
+
+unsigned int CAESinkSteamLink::AddPackets(uint8_t **data, unsigned int frames, unsigned int offset)
+{
+  const double packetTimeSecs = 1.0 * (frames - offset) / m_format.m_sampleRate;
+
+  // Update delay for elapsed time
+  const double nowSecs = (double)CurrentHostCounter() / CurrentHostFrequency();
+  if (m_lastPackageStamp > 0.0)
+  {
+    const double elapsedSecs = nowSecs - m_lastPackageStamp;
+    m_delaySec -= elapsedSecs;
+    if (m_delaySec < 0.0)
+      m_delaySec = 0.0;
+  }
+  m_lastPackageStamp = nowSecs;
+
+  // Ensure space in the buffer
+  const double availableSecs = GetCacheTotal() - GetDelaySecs();
+
+  const int sleepTimeUs = (int)((SINK_FEED_MS / 1000.0 - availableSecs) * 1000 * 1000);
+
+  if (sleepTimeUs > 0)
+    usleep(sleepTimeUs);
+
+  CAudioChunk chunk;
+  chunk.m_nSize = (frames - offset) * m_format.m_frameSize;
+  chunk.m_pData = new uint8_t[chunk.m_nSize];
+  std::memcpy(chunk.m_pData, data[0] + offset * m_format.m_frameSize, chunk.m_nSize);
+  if (m_initialAttenuation)
+  {
+    double flVolume = (nowSecs - m_startTime) / INITIAL_ATTENUATION_TIME;
+    flVolume *= flVolume;
+    if (flVolume < 1.0)
+      AttenuateChunk(&chunk, flVolume);
+    else
+      m_initialAttenuation = false;
+  }
+  chunk.m_nNowSecs = nowSecs + g_unQueuedVideoMS / 1000.0 + DELAY_OFFSET_SECONDS;
+  m_AudioQueue.push( chunk );
+
+  while (m_AudioQueue.size() > 0)
+  {
+    chunk = m_AudioQueue.front();
+    if (chunk.m_nNowSecs > nowSecs + 0.001)
+    {
+      break;
+    }
+
+    m_AudioQueue.pop();
+
+    void* buffer = SLAudio_BeginFrame(m_stream);
+    std::memcpy(buffer, chunk.m_pData, chunk.m_nSize);
+    SLAudio_SubmitFrame(m_stream);
+    delete[] chunk.m_pData;
+  }
+
+  // Increase the delay for the added packet
+  m_delaySec += packetTimeSecs;
+
+  return frames - offset;
+}
+
+void CAESinkSteamLink::GetDelay(AEDelayStatus &status)
+{
+  status.SetDelay(GetDelaySecs());
+}
+
+void CAESinkSteamLink::AttenuateChunk(CAudioChunk *pChunk, double flVolume)
+{
+  int16_t *pData = (int16_t*)pChunk->m_pData;
+  int nCount = pChunk->m_nSize / sizeof(*pData);
+  while (nCount--)
+  {
+    *pData = static_cast<int16_t>(*pData * flVolume);
+    ++pData;
+  }
+}
+
+void CAESinkSteamLink::Drain()
+{
+  unsigned int usecs = (unsigned int)(GetDelaySecs() * 1000 * 1000);
+  if (usecs > 0)
+    usleep(usecs);
+
+  m_lastPackageStamp = 0.0;
+  m_delaySec = 0.0;
+
+  while (m_AudioQueue.size() > 0)
+  {
+    delete[] m_AudioQueue.front().m_pData;
+    m_AudioQueue.pop();
+  }
+  g_unQueuedVideoMS = 0;
+}
+
+double CAESinkSteamLink::GetDelaySecs()
+{
+  return m_delaySec;
+}
+
+void CAESinkSteamLink::EnumerateDevicesEx(AEDeviceInfoList &deviceInfoList, bool force /* = false */)
+{
+  CAEDeviceInfo info;
+
+  info.m_deviceType = AE_DEVTYPE_PCM;
+  info.m_deviceName = "SteamLink";
+  info.m_displayName = "Steam Link Low Latency Audio";
+  info.m_displayNameExtra = "";
+  info.m_channels += AE_CH_FL;
+  info.m_channels += AE_CH_FR;
+  info.m_sampleRates.push_back(SL_SAMPLE_RATE);
+  info.m_dataFormats.push_back(AE_FMT_S16NE);
+
+  deviceInfoList.push_back(info);
+}
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.h b/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.h
new file mode 100644
index 0000000..e354fac
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.h
@@ -0,0 +1,81 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      Copyright (C) 2016 Valve Corporation
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "cores/AudioEngine/Interfaces/AESink.h"
+#include "cores/AudioEngine/Utils/AEDeviceInfo.h"
+
+#include <stdint.h>
+#include <queue>
+
+#define STEAM_LINK_SINK_NAME  "SteamLinkAudio"
+
+struct CSLAudioContext;
+struct CSLAudioStream;
+
+namespace STEAMLINK
+{
+
+class CAESinkSteamLink : public IAESink
+{
+public:
+  virtual const char* GetName() override { return STEAM_LINK_SINK_NAME; }
+
+  CAESinkSteamLink();
+  virtual ~CAESinkSteamLink();
+
+  // implementation of IAESink
+  virtual bool Initialize(AEAudioFormat &format, std::string &device) override;
+  virtual void Deinitialize() override;
+  virtual double GetCacheTotal() override;
+  virtual unsigned int AddPackets(uint8_t **data, unsigned int frames, unsigned int offset) override;
+  virtual void GetDelay(AEDelayStatus &status) override;
+  virtual void Drain() override;
+
+  static void EnumerateDevicesEx(AEDeviceInfoList &deviceInfoList, bool force = false);
+
+private:
+  double GetDelaySecs();
+
+  // AE stuff
+  AEAudioFormat m_format;
+  double        m_lastPackageStamp;
+  double        m_delaySec; // Estimated delay in seconds
+
+  // Steam Link stuff
+  CSLAudioContext *m_context;
+  CSLAudioStream *m_stream;
+
+  // Queued audio for video sync
+  struct CAudioChunk
+  {
+    uint8_t *m_pData;
+    unsigned int m_nSize;
+    double m_nNowSecs;
+  };
+  std::queue<CAudioChunk> m_AudioQueue;
+
+  // Initial attenuation to cover audio sync
+  double m_startTime;
+  bool m_initialAttenuation;
+  void AttenuateChunk(CAudioChunk *pChunk, double flVolume);
+};
+
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
index 9717412..cade549 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -41,6 +41,9 @@
 #include "Video/DVDVideoCodecAndroidMediaCodec.h"
 #include "platform/android/activity/AndroidFeatures.h"
 #endif
+#if defined(HAS_STEAMLINK)
+#include "Video/SteamLinkVideo.h"
+#endif
 #include "Audio/DVDAudioCodecFFmpeg.h"
 #include "Audio/DVDAudioCodecPassthrough.h"
 #include "Overlay/DVDOverlayCodecSSA.h"
@@ -141,7 +144,9 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, CProces
       return pCodec;
 #endif
 
-#if defined(HAS_IMXVPU)
+#if defined(HAS_STEAMLINK)
+    pCodec = OpenCodec(new STEAMLINK::CSteamLinkVideo(processInfo), hint, options);
+#elif defined(HAS_IMXVPU)
     pCodec = OpenCodec(new CDVDVideoCodecIMX(processInfo), hint, options);
 #elif defined(TARGET_ANDROID)
     pCodec = OpenCodec(new CDVDVideoCodecAndroidMediaCodec(processInfo), hint, options);
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in
index 62d44ce..50f13d7 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in
@@ -34,6 +34,10 @@ ifeq (@USE_MMAL@,1)
 SRCS += MMALCodec.cpp MMALFFmpeg.cpp
 endif
 
+ifeq (@USE_STEAMLINK@,1)
+SRCS += SteamLinkVideo.cpp
+endif
+
 LIB=Video.a
 
 include @abs_top_srcdir@/Makefile.include
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/SteamLinkVideo.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/SteamLinkVideo.cpp
new file mode 100644
index 0000000..8571eb9
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/SteamLinkVideo.cpp
@@ -0,0 +1,405 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      Copyright (C) 2016 Valve Corporation
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "SteamLinkVideo.h"
+#include "cores/VideoPlayer/DVDClock.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "settings/AdvancedSettings.h"
+#include "utils/log.h"
+
+// Steam Link video API
+#include "SLVideo.h"
+
+#include <string.h>
+
+using namespace STEAMLINK;
+
+namespace STEAMLINK
+{
+  uint32_t g_unQueuedVideoMS = 0;
+}
+
+namespace
+{
+  void LogFunction(void *pContext, ESLVideoLog eLogLevel, const char *pszMessage)
+  {
+    switch (eLogLevel)
+    {
+    case k_ESLVideoLogDebug:
+      CLog::Log(LOGDEBUG, "%s", pszMessage);
+      break;
+    case k_ESLVideoLogInfo:
+      CLog::Log(LOGINFO, "%s", pszMessage);
+      break;
+    case k_ESLVideoLogWarning:
+      CLog::Log(LOGWARNING, "%s", pszMessage);
+      break;
+    case k_ESLVideoLogError:
+      CLog::Log(LOGERROR, "%s", pszMessage);
+      break;
+    default:
+      break;
+    }
+  }
+
+}
+
+CSteamLinkVideo::CSteamLinkVideo(CProcessInfo& processInfo) :
+  CDVDVideoCodec(processInfo),
+  m_context(nullptr),
+  m_stream(nullptr),
+  m_sps_pps_size(0),
+  m_convert_bitstream(false)
+{
+  SLVideo_SetLogLevel(g_advancedSettings.CanLogComponent(LOGVIDEO) ? k_ESLVideoLogDebug : k_ESLVideoLogError);
+  SLVideo_SetLogFunction(LogFunction, nullptr);
+}
+
+CSteamLinkVideo::~CSteamLinkVideo()
+{
+  Dispose();
+  SLVideo_SetLogFunction(nullptr, nullptr);
+}
+
+bool CSteamLinkVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  if (hints.software)
+    return false;
+
+  Dispose();
+
+  CSLVideoContext* context = SLVideo_CreateContext();
+  if (context)
+  {
+    CSLVideoStream* stream = nullptr;
+
+    switch (hints.codec)
+    {
+      case AV_CODEC_ID_H264:
+        if (hints.extrasize < 7 || hints.extradata == NULL)
+        {
+          CLog::Log(LOGNOTICE,
+            "%s: avcC data too small or missing", GetName());
+          return false;
+        }
+        // valid avcC data (bitstream) always starts with the value 1 (version)
+        if (*(char*)hints.extradata == 1)
+          m_convert_bitstream = bitstream_convert_init(hints.extradata, hints.extrasize);
+
+        stream = SLVideo_CreateStream(context, k_ESLVideoFormatH264, false);
+
+        if (stream && hints.fpsscale > 0)
+          SLVideo_SetStreamTargetFramerate(stream, hints.fpsrate, hints.fpsscale);
+        break;
+      default:
+        if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+          CLog::Log(LOGDEBUG, "%s: Codec not supported", GetName());
+        break;
+    }
+
+    if (stream)
+    {
+      // Success
+      m_context = context;
+      m_stream = stream;
+
+      if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+      {
+        int width = 0;
+        int height = 0;
+        SLVideo_GetDisplayResolution(m_context, &width, &height);
+
+        CLog::Log(LOGDEBUG, "%s: Display resolution = %d x %d", GetName(), width, height);
+      }
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "%s: Failed to create stream", GetName());
+      SLVideo_FreeContext(context);
+    }
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "%s: Failed to create context", GetName());
+  }
+
+  return m_context != nullptr;
+}
+
+void CSteamLinkVideo::Dispose()
+{
+  if (m_stream)
+  {
+    SLVideo_FreeStream(m_stream);
+    m_stream = nullptr;
+  }
+  if (m_context)
+  {
+    SLVideo_FreeContext(m_context);
+    m_context = nullptr;
+  }
+  if (m_convert_bitstream)
+  {
+    if (m_sps_pps_context.sps_pps_data)
+    {
+      free(m_sps_pps_context.sps_pps_data);
+      m_sps_pps_context.sps_pps_data = NULL;
+    }
+    m_convert_bitstream = false;
+  }
+  g_unQueuedVideoMS = 0;
+}
+
+int CSteamLinkVideo::Decode(uint8_t *pData, int iSize, double dts, double pts)
+{
+  if (!pData || iSize == 0)
+    return VC_BUFFER;
+
+  int demuxer_bytes = iSize;
+  uint8_t *demuxer_content = pData;
+  bool bitstream_convered  = false;
+
+  if (m_convert_bitstream)
+  {
+    // convert demuxer packet from bitstream to bytestream (AnnexB)
+    int bytestream_size = 0;
+    uint8_t *bytestream_buff = NULL;
+
+    bitstream_convert(demuxer_content, demuxer_bytes, &bytestream_buff, &bytestream_size);
+    if (bytestream_buff && (bytestream_size > 0))
+    {
+      bitstream_convered = true;
+      demuxer_bytes = bytestream_size;
+      demuxer_content = bytestream_buff;
+    }
+  }
+
+  if (SLVideo_BeginFrame(m_stream, demuxer_bytes) != 0)
+  {
+    CLog::Log(LOGERROR, "%s: Failed to begin frame", GetName());
+    return VC_ERROR;
+  }
+
+  if (SLVideo_WriteFrameData(m_stream, demuxer_content, demuxer_bytes) != 0)
+  {
+    CLog::Log(LOGERROR, "%s: Error writing data", GetName());
+    return VC_ERROR;
+  }
+
+  if (SLVideo_SubmitFrame(m_stream) != 0)
+  {
+    CLog::Log(LOGERROR, "%s: Error submitting frame", GetName());
+    return VC_ERROR;
+  }
+
+  if (bitstream_convered)
+    free(demuxer_content);
+
+  g_unQueuedVideoMS = SLVideo_GetQueuedVideoMS(m_stream);
+
+  return VC_PICTURE;
+}
+
+void CSteamLinkVideo::Reset(void)
+{
+  // TODO
+}
+
+bool CSteamLinkVideo::GetPicture(DVDVideoPicture *pDvdVideoPicture)
+{
+  int width = 0;
+  int height = 0;
+  SLVideo_GetDisplayResolution(m_context, &width, &height);
+
+  memset(pDvdVideoPicture, 0, sizeof(*pDvdVideoPicture));
+
+  pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+  pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
+  pDvdVideoPicture->iWidth = width;
+  pDvdVideoPicture->iHeight= height;
+  pDvdVideoPicture->iDisplayWidth = width;
+  pDvdVideoPicture->iDisplayHeight= height;
+  pDvdVideoPicture->format = RENDER_FMT_STEAMLINK;
+
+  return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////
+bool CSteamLinkVideo::bitstream_convert_init(void *in_extradata, int in_extrasize)
+{
+  // based on h264_mp4toannexb_bsf.c (ffmpeg)
+  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
+  // and Licensed GPL 2.1 or greater
+
+  m_sps_pps_size = 0;
+  m_sps_pps_context.sps_pps_data = NULL;
+  
+  // nothing to filter
+  if (!in_extradata || in_extrasize < 6)
+    return false;
+
+  uint16_t unit_size;
+  uint32_t total_size = 0;
+  uint8_t *out = NULL, unit_nb, sps_done = 0;
+  const uint8_t *extradata = (uint8_t*)in_extradata + 4;
+  static const uint8_t nalu_header[4] = {0, 0, 0, 1};
+
+  // retrieve length coded size
+  m_sps_pps_context.length_size = (*extradata++ & 0x3) + 1;
+  if (m_sps_pps_context.length_size == 3)
+    return false;
+
+  // retrieve sps and pps unit(s)
+  unit_nb = *extradata++ & 0x1f;  // number of sps unit(s)
+  if (!unit_nb)
+  {
+    unit_nb = *extradata++;       // number of pps unit(s)
+    sps_done++;
+  }
+  while (unit_nb--)
+  {
+    unit_size = extradata[0] << 8 | extradata[1];
+    total_size += unit_size + 4;
+    if ( (extradata + 2 + unit_size) > ((uint8_t*)in_extradata + in_extrasize) )
+    {
+      free(out);
+      return false;
+    }
+    uint8_t* new_out = (uint8_t*)realloc(out, total_size);
+    if (new_out)
+    {
+      out = new_out;
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "bitstream_convert_init failed - %s : could not realloc the buffer out",  __FUNCTION__);
+      free(out);
+      return false;
+    }
+
+    memcpy(out + total_size - unit_size - 4, nalu_header, 4);
+    memcpy(out + total_size - unit_size, extradata + 2, unit_size);
+    extradata += 2 + unit_size;
+
+    if (!unit_nb && !sps_done++)
+      unit_nb = *extradata++;     // number of pps unit(s)
+  }
+
+  m_sps_pps_context.sps_pps_data = out;
+  m_sps_pps_context.size = total_size;
+  m_sps_pps_context.first_idr = 1;
+
+  return true;
+}
+
+bool CSteamLinkVideo::bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size)
+{
+  // based on h264_mp4toannexb_bsf.c (ffmpeg)
+  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
+  // and Licensed GPL 2.1 or greater
+
+  uint8_t *buf = pData;
+  uint32_t buf_size = iSize;
+  uint8_t  unit_type;
+  int32_t  nal_size;
+  uint32_t cumul_size = 0;
+  const uint8_t *buf_end = buf + buf_size;
+
+  do
+  {
+    if (buf + m_sps_pps_context.length_size > buf_end)
+      goto fail;
+
+    if (m_sps_pps_context.length_size == 1)
+      nal_size = buf[0];
+    else if (m_sps_pps_context.length_size == 2)
+      nal_size = buf[0] << 8 | buf[1];
+    else
+      nal_size = buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];
+
+    buf += m_sps_pps_context.length_size;
+    unit_type = *buf & 0x1f;
+
+    if (buf + nal_size > buf_end || nal_size < 0)
+      goto fail;
+
+    // prepend only to the first type 5 NAL unit of an IDR picture
+    if (m_sps_pps_context.first_idr && unit_type == 5)
+    {
+      bitstream_alloc_and_copy(poutbuf, poutbuf_size,
+        m_sps_pps_context.sps_pps_data, m_sps_pps_context.size, buf, nal_size);
+      m_sps_pps_context.first_idr = 0;
+    }
+    else
+    {
+      bitstream_alloc_and_copy(poutbuf, poutbuf_size, NULL, 0, buf, nal_size);
+      if (!m_sps_pps_context.first_idr && unit_type == 1)
+          m_sps_pps_context.first_idr = 1;
+    }
+
+    buf += nal_size;
+    cumul_size += nal_size + m_sps_pps_context.length_size;
+  } while (cumul_size < buf_size);
+
+  return true;
+
+fail:
+  free(*poutbuf);
+  *poutbuf = NULL;
+  *poutbuf_size = 0;
+  return false;
+}
+
+void CSteamLinkVideo::bitstream_alloc_and_copy(
+  uint8_t **poutbuf,      int *poutbuf_size,
+  const uint8_t *sps_pps, uint32_t sps_pps_size,
+  const uint8_t *in,      uint32_t in_size)
+{
+  // based on h264_mp4toannexb_bsf.c (ffmpeg)
+  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
+  // and Licensed GPL 2.1 or greater
+
+  #define CHD_WB32(p, d) { \
+    ((uint8_t*)(p))[3] = (d); \
+    ((uint8_t*)(p))[2] = (d) >> 8; \
+    ((uint8_t*)(p))[1] = (d) >> 16; \
+    ((uint8_t*)(p))[0] = (d) >> 24; }
+
+  uint32_t offset = *poutbuf_size;
+  uint8_t nal_header_size = 4;//offset ? 3 : 4;
+
+  *poutbuf_size += sps_pps_size + nal_header_size + in_size;
+  *poutbuf = (uint8_t*)realloc(*poutbuf, *poutbuf_size);
+  if (sps_pps)
+    memcpy(*poutbuf + offset, sps_pps, sps_pps_size);
+
+  memcpy(*poutbuf + offset + sps_pps_size + nal_header_size, in, in_size);
+  if (true || !offset)
+  {
+    CHD_WB32(*poutbuf + offset + sps_pps_size, 1);
+  }
+  else
+  {
+    (*poutbuf + offset + sps_pps_size)[0] = 0;
+    (*poutbuf + offset + sps_pps_size)[1] = 0;
+    (*poutbuf + offset + sps_pps_size)[2] = 1;
+  }
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/SteamLinkVideo.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/SteamLinkVideo.h
new file mode 100644
index 0000000..8465fad
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/SteamLinkVideo.h
@@ -0,0 +1,85 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      Copyright (C) 2016 Valve Corporation
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "DVDVideoCodec.h"
+
+#include <stdint.h>
+#include <string>
+
+#define STEAMLINK_VIDEO_CODEC_NAME  "SteamLinkVideo"
+
+struct CSLVideoContext;
+struct CSLVideoStream;
+
+namespace STEAMLINK
+{
+
+class CSteamLinkVideo : public CDVDVideoCodec
+{
+public:
+  CSteamLinkVideo(CProcessInfo& processInfo);
+  virtual ~CSteamLinkVideo();
+
+  // implementation of CDVDVideoCodec
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) override;
+  virtual int Decode(uint8_t* pData, int iSize, double dts, double pts) override;
+  virtual void Reset() override;
+  virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture) override;
+  virtual void SetDropState(bool bDrop) override { }
+  virtual const char* GetName() override { return STEAMLINK_VIDEO_CODEC_NAME; }
+
+private:
+  void Dispose();
+
+  // Steam Link data
+  CSLVideoContext* m_context;
+  CSLVideoStream* m_stream;
+
+  // bitstream to bytestream (Annex B) conversion support.
+  bool bitstream_convert_init(void *in_extradata, int in_extrasize);
+  bool bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size);
+  static void bitstream_alloc_and_copy(uint8_t **poutbuf, int *poutbuf_size,
+    const uint8_t *sps_pps, uint32_t sps_pps_size, const uint8_t *in, uint32_t in_size);
+
+  typedef struct bitstream_ctx
+  {
+      uint8_t  length_size;
+      uint8_t  first_idr;
+      uint8_t *sps_pps_data;
+      uint32_t size;
+
+      bitstream_ctx()
+      {
+        length_size = 0;
+        first_idr = 0;
+        sps_pps_data = NULL;
+        size = 0;
+      }
+
+  } bitstream_ctx;
+
+  uint32_t      m_sps_pps_size;
+  bitstream_ctx m_sps_pps_context;
+  bool          m_convert_bitstream;
+};
+
+}
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/Makefile.in b/xbmc/cores/VideoPlayer/VideoRenderers/Makefile.in
index 83547f6..0dfe8ed 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/Makefile.in
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/Makefile.in
@@ -24,6 +24,10 @@ SRCS += OverlayRendererGL.cpp
 SRCS += FrameBufferObject.cpp
 endif
 
+ifeq (@USE_STEAMLINK@,1)
+SRCS += SteamLinkRenderer.cpp
+endif
+
 LIB = VideoRenderer.a
 
 include @abs_top_srcdir@/Makefile.include
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFormats.h b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFormats.h
index 39f62fa..6d2c2d0 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFormats.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFormats.h
@@ -45,6 +45,7 @@ enum ERenderFormat {
   RENDER_FMT_IMXMAP,
   RENDER_FMT_MMAL,
   RENDER_FMT_AML,
+  RENDER_FMT_STEAMLINK,
 };
 
 struct CRenderInfo
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
index 482142e..b6ba703 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
@@ -63,6 +63,9 @@
 #elif defined(HAS_SDL)
   #include "LinuxRenderer.h"
 #endif
+#if defined(HAS_STEAMLINK)
+  #include "SteamLinkRenderer.h"
+#endif
 
 #if defined(TARGET_ANDROID)
 #include "HwDecRender/RendererMediaCodec.h"
@@ -111,6 +114,7 @@ static std::string GetRenderFormatName(ERenderFormat format)
     case RENDER_FMT_IMXMAP:    return "IMXMAP";
     case RENDER_FMT_MMAL:      return "MMAL";
     case RENDER_FMT_AML:       return "AMLCODEC";
+    case RENDER_FMT_STEAMLINK: return "STEAMLINK";
     case RENDER_FMT_NONE:      return "NONE";
   }
   return "UNKNOWN";
@@ -579,7 +583,9 @@ void CRenderManager::CreateRenderer()
     }
     else if (m_format != RENDER_FMT_NONE)
     {
-#if defined(HAS_MMAL)
+#if defined(HAS_STEAMLINK)
+      m_pRenderer = new STEAMLINK::CSteamLinkRenderer;
+#elif defined(HAS_MMAL)
       m_pRenderer = new CMMALRenderer;
 #elif defined(HAS_GL)
       m_pRenderer = new CLinuxRendererGL;
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/SteamLinkRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/SteamLinkRenderer.cpp
new file mode 100644
index 0000000..d623fac
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/SteamLinkRenderer.cpp
@@ -0,0 +1,39 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      Copyright (C) 2016 Valve Corporation
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "SteamLinkRenderer.h"
+#include "utils/log.h"
+
+#include <GLES2/gl2.h>
+
+using namespace STEAMLINK;
+
+bool CSteamLinkRenderer::LoadShadersHook()
+{
+  CLog::Log(LOGNOTICE, "CSteamLinkRenderer: Using STEAMLINK render method");
+  m_textureTarget = GL_TEXTURE_2D;
+  m_renderMethod = RENDER_BYPASS;
+  return false;
+}
+
+int CSteamLinkRenderer::GetImageHook(YV12Image *image, int source /* = AUTOSOURCE */, bool readonly /* = false */)
+{
+  return source;
+}
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/SteamLinkRenderer.h b/xbmc/cores/VideoPlayer/VideoRenderers/SteamLinkRenderer.h
new file mode 100644
index 0000000..9f609b9
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/SteamLinkRenderer.h
@@ -0,0 +1,49 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      Copyright (C) 2016 Valve Corporation
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "system.h" // for HAS_GLES, needed for LinuxRendererGLES.h
+
+#include "cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h"
+
+namespace STEAMLINK
+{
+
+class CSteamLinkRenderer : public CLinuxRendererGLES
+{
+public:
+  CSteamLinkRenderer() { }
+  virtual ~CSteamLinkRenderer() { }
+
+  // implementation of CBaseRenderer via CLinuxRendererGLES
+  virtual bool IsGuiLayer() override { return false; }
+  virtual bool SupportsMultiPassRendering() override { return false; }
+  virtual bool Supports(ERENDERFEATURE feature) override { return false; }
+  virtual bool Supports(ESCALINGMETHOD method) override { return false; }
+
+protected:
+  // implementation of CLinuxRendererGLES
+  bool LoadShadersHook();
+  bool RenderHook(int index) { return true; }
+  bool RenderUpdateVideoHook(bool clear, DWORD flags = 0, DWORD alpha = 255) { return true; }
+  int  GetImageHook(YV12Image *image, int source = -1, bool readonly = false);
+};
+
+}
diff --git a/xbmc/windowing/WinEventsSDL.cpp b/xbmc/windowing/WinEventsSDL.cpp
index b0658d1..30d361f 100644
--- a/xbmc/windowing/WinEventsSDL.cpp
+++ b/xbmc/windowing/WinEventsSDL.cpp
@@ -36,7 +36,7 @@
 #include "platform/darwin/osx/CocoaInterface.h"
 #endif
 
-#if defined(TARGET_POSIX) && !defined(TARGET_DARWIN) && !defined(TARGET_ANDROID)
+#ifdef HAVE_X11
 #include <X11/Xlib.h>
 #include <X11/XKBlib.h>
 #include "input/XBMC_keysym.h"
@@ -45,7 +45,7 @@
 
 using namespace KODI::MESSAGING;
 
-#if defined(TARGET_POSIX) && !defined(TARGET_DARWIN)
+#ifdef HAVE_X11
 // The following chunk of code is Linux specific. For keys that have
 // with keysym.sym set to zero it checks the scan code, and sets the sym
 // for some known scan codes. This is mostly the multimedia keys.
@@ -215,6 +215,276 @@ static uint16_t SymFromScancode(uint16_t scancode)
 }
 #endif // End of checks for keysym.sym == 0
 
+#if HAVE_SDL_VERSION == 2
+// The keysyms changed from SDL 1 to SDL 2, so create a mapping
+static std::map<SDL_Keycode, XBMCKey> s_keysymTable;
+
+static void InitializeKeysymLookup()
+{
+    s_keysymTable[SDLK_RETURN] = XBMCK_RETURN;
+    s_keysymTable[SDLK_ESCAPE] = XBMCK_ESCAPE;
+    s_keysymTable[SDLK_BACKSPACE] = XBMCK_BACKSPACE;
+    s_keysymTable[SDLK_TAB] = XBMCK_TAB;
+    s_keysymTable[SDLK_SPACE] = XBMCK_SPACE;
+    s_keysymTable[SDLK_EXCLAIM] = XBMCK_EXCLAIM;
+    s_keysymTable[SDLK_QUOTEDBL] = XBMCK_QUOTEDBL;
+    s_keysymTable[SDLK_HASH] = XBMCK_HASH;
+    s_keysymTable[SDLK_PERCENT] = XBMCK_PERCENT;
+    s_keysymTable[SDLK_DOLLAR] = XBMCK_DOLLAR;
+    s_keysymTable[SDLK_AMPERSAND] = XBMCK_AMPERSAND;
+    s_keysymTable[SDLK_QUOTE] = XBMCK_QUOTE;
+    s_keysymTable[SDLK_LEFTPAREN] = XBMCK_LEFTPAREN;
+    s_keysymTable[SDLK_RIGHTPAREN] = XBMCK_RIGHTPAREN;
+    s_keysymTable[SDLK_ASTERISK] = XBMCK_ASTERISK;
+    s_keysymTable[SDLK_PLUS] = XBMCK_PLUS;
+    s_keysymTable[SDLK_COMMA] = XBMCK_COMMA;
+    s_keysymTable[SDLK_MINUS] = XBMCK_MINUS;
+    s_keysymTable[SDLK_PERIOD] = XBMCK_PERIOD;
+    s_keysymTable[SDLK_SLASH] = XBMCK_SLASH;
+    s_keysymTable[SDLK_0] = XBMCK_0;
+    s_keysymTable[SDLK_1] = XBMCK_1;
+    s_keysymTable[SDLK_2] = XBMCK_2;
+    s_keysymTable[SDLK_3] = XBMCK_3;
+    s_keysymTable[SDLK_4] = XBMCK_4;
+    s_keysymTable[SDLK_5] = XBMCK_5;
+    s_keysymTable[SDLK_6] = XBMCK_6;
+    s_keysymTable[SDLK_7] = XBMCK_7;
+    s_keysymTable[SDLK_8] = XBMCK_8;
+    s_keysymTable[SDLK_9] = XBMCK_9;
+    s_keysymTable[SDLK_COLON] = XBMCK_COLON;
+    s_keysymTable[SDLK_SEMICOLON] = XBMCK_SEMICOLON;
+    s_keysymTable[SDLK_LESS] = XBMCK_LESS;
+    s_keysymTable[SDLK_EQUALS] = XBMCK_EQUALS;
+    s_keysymTable[SDLK_GREATER] = XBMCK_GREATER;
+    s_keysymTable[SDLK_QUESTION] = XBMCK_QUESTION;
+    s_keysymTable[SDLK_AT] = XBMCK_AT;
+    s_keysymTable[SDLK_LEFTBRACKET] = XBMCK_LEFTBRACKET;
+    s_keysymTable[SDLK_BACKSLASH] = XBMCK_BACKSLASH;
+    s_keysymTable[SDLK_RIGHTBRACKET] = XBMCK_RIGHTBRACKET;
+    s_keysymTable[SDLK_CARET] = XBMCK_CARET;
+    s_keysymTable[SDLK_UNDERSCORE] = XBMCK_UNDERSCORE;
+    s_keysymTable[SDLK_BACKQUOTE] = XBMCK_BACKQUOTE;
+    s_keysymTable[SDLK_a] = XBMCK_a;
+    s_keysymTable[SDLK_b] = XBMCK_b;
+    s_keysymTable[SDLK_c] = XBMCK_c;
+    s_keysymTable[SDLK_d] = XBMCK_d;
+    s_keysymTable[SDLK_e] = XBMCK_e;
+    s_keysymTable[SDLK_f] = XBMCK_f;
+    s_keysymTable[SDLK_g] = XBMCK_g;
+    s_keysymTable[SDLK_h] = XBMCK_h;
+    s_keysymTable[SDLK_i] = XBMCK_i;
+    s_keysymTable[SDLK_j] = XBMCK_j;
+    s_keysymTable[SDLK_k] = XBMCK_k;
+    s_keysymTable[SDLK_l] = XBMCK_l;
+    s_keysymTable[SDLK_m] = XBMCK_m;
+    s_keysymTable[SDLK_n] = XBMCK_n;
+    s_keysymTable[SDLK_o] = XBMCK_o;
+    s_keysymTable[SDLK_p] = XBMCK_p;
+    s_keysymTable[SDLK_q] = XBMCK_q;
+    s_keysymTable[SDLK_r] = XBMCK_r;
+    s_keysymTable[SDLK_s] = XBMCK_s;
+    s_keysymTable[SDLK_t] = XBMCK_t;
+    s_keysymTable[SDLK_u] = XBMCK_u;
+    s_keysymTable[SDLK_v] = XBMCK_v;
+    s_keysymTable[SDLK_w] = XBMCK_w;
+    s_keysymTable[SDLK_x] = XBMCK_x;
+    s_keysymTable[SDLK_y] = XBMCK_y;
+    s_keysymTable[SDLK_z] = XBMCK_z;
+    s_keysymTable[SDLK_CAPSLOCK] = XBMCK_CAPSLOCK;
+    s_keysymTable[SDLK_F1] = XBMCK_F1;
+    s_keysymTable[SDLK_F2] = XBMCK_F2;
+    s_keysymTable[SDLK_F3] = XBMCK_F3;
+    s_keysymTable[SDLK_F4] = XBMCK_F4;
+    s_keysymTable[SDLK_F5] = XBMCK_F5;
+    s_keysymTable[SDLK_F6] = XBMCK_F6;
+    s_keysymTable[SDLK_F7] = XBMCK_F7;
+    s_keysymTable[SDLK_F8] = XBMCK_F8;
+    s_keysymTable[SDLK_F9] = XBMCK_F9;
+    s_keysymTable[SDLK_F10] = XBMCK_F10;
+    s_keysymTable[SDLK_F11] = XBMCK_F11;
+    s_keysymTable[SDLK_F12] = XBMCK_F12;
+    s_keysymTable[SDLK_PRINTSCREEN] = XBMCK_PRINT;
+    s_keysymTable[SDLK_SCROLLLOCK] = XBMCK_SCROLLOCK;
+    s_keysymTable[SDLK_PAUSE] = XBMCK_PAUSE;
+    s_keysymTable[SDLK_INSERT] = XBMCK_INSERT;
+    s_keysymTable[SDLK_HOME] = XBMCK_HOME;
+    s_keysymTable[SDLK_PAGEUP] = XBMCK_PAGEUP;
+    s_keysymTable[SDLK_DELETE] = XBMCK_DELETE;
+    s_keysymTable[SDLK_END] = XBMCK_END;
+    s_keysymTable[SDLK_PAGEDOWN] = XBMCK_PAGEDOWN;
+    s_keysymTable[SDLK_RIGHT] = XBMCK_RIGHT;
+    s_keysymTable[SDLK_LEFT] = XBMCK_LEFT;
+    s_keysymTable[SDLK_DOWN] = XBMCK_DOWN;
+    s_keysymTable[SDLK_UP] = XBMCK_UP;
+    s_keysymTable[SDLK_NUMLOCKCLEAR] = XBMCK_NUMLOCK;
+    s_keysymTable[SDLK_KP_DIVIDE] = XBMCK_KP_DIVIDE;
+    s_keysymTable[SDLK_KP_MULTIPLY] = XBMCK_KP_MULTIPLY;
+    s_keysymTable[SDLK_KP_MINUS] = XBMCK_KP_MINUS;
+    s_keysymTable[SDLK_KP_PLUS] = XBMCK_KP_PLUS;
+    s_keysymTable[SDLK_KP_ENTER] = XBMCK_KP_ENTER;
+    s_keysymTable[SDLK_KP_1] = XBMCK_KP1;
+    s_keysymTable[SDLK_KP_2] = XBMCK_KP2;
+    s_keysymTable[SDLK_KP_3] = XBMCK_KP3;
+    s_keysymTable[SDLK_KP_4] = XBMCK_KP4;
+    s_keysymTable[SDLK_KP_5] = XBMCK_KP5;
+    s_keysymTable[SDLK_KP_6] = XBMCK_KP6;
+    s_keysymTable[SDLK_KP_7] = XBMCK_KP7;
+    s_keysymTable[SDLK_KP_8] = XBMCK_KP8;
+    s_keysymTable[SDLK_KP_9] = XBMCK_KP9;
+    s_keysymTable[SDLK_KP_0] = XBMCK_KP0;
+    s_keysymTable[SDLK_KP_PERIOD] = XBMCK_KP_PERIOD;
+    s_keysymTable[SDLK_APPLICATION] = XBMCK_LAUNCH_APP1;
+    s_keysymTable[SDLK_POWER] = XBMCK_POWER;
+    s_keysymTable[SDLK_KP_EQUALS] = XBMCK_KP_EQUALS;
+    s_keysymTable[SDLK_F13] = XBMCK_F13;
+    s_keysymTable[SDLK_F14] = XBMCK_F14;
+    s_keysymTable[SDLK_F15] = XBMCK_F15;
+/*
+    s_keysymTable[SDLK_F16] = XBMCK_F16;
+    s_keysymTable[SDLK_F17] = XBMCK_F17;
+    s_keysymTable[SDLK_F18] = XBMCK_F18;
+    s_keysymTable[SDLK_F19] = XBMCK_F19;
+    s_keysymTable[SDLK_F20] = XBMCK_F20;
+    s_keysymTable[SDLK_F21] = XBMCK_F21;
+    s_keysymTable[SDLK_F22] = XBMCK_F22;
+    s_keysymTable[SDLK_F23] = XBMCK_F23;
+    s_keysymTable[SDLK_F24] = XBMCK_F24;
+    s_keysymTable[SDLK_EXECUTE] = XBMCK_EXECUTE;
+*/
+    s_keysymTable[SDLK_HELP] = XBMCK_HELP;
+    s_keysymTable[SDLK_MENU] = XBMCK_MENU;
+/*
+    s_keysymTable[SDLK_SELECT] = XBMCK_SELECT;
+    s_keysymTable[SDLK_STOP] = XBMCK_STOP;
+    s_keysymTable[SDLK_AGAIN] = XBMCK_AGAIN;
+    s_keysymTable[SDLK_UNDO] = XBMCK_UNDO;
+    s_keysymTable[SDLK_CUT] = XBMCK_CUT;
+    s_keysymTable[SDLK_COPY] = XBMCK_COPY;
+    s_keysymTable[SDLK_PASTE] = XBMCK_PASTE;
+    s_keysymTable[SDLK_FIND] = XBMCK_FIND;
+*/
+    s_keysymTable[SDLK_MUTE] = XBMCK_VOLUME_MUTE;
+    s_keysymTable[SDLK_VOLUMEUP] = XBMCK_VOLUME_UP;
+    s_keysymTable[SDLK_VOLUMEDOWN] = XBMCK_VOLUME_DOWN;
+/*
+    s_keysymTable[SDLK_KP_COMMA] = XBMCK_KP_COMMA;
+    s_keysymTable[SDLK_KP_EQUALSAS400] = XBMCK_KP_EQUALSAS400;
+    s_keysymTable[SDLK_ALTERASE] = XBMCK_ALTERASE;
+*/
+    s_keysymTable[SDLK_SYSREQ] = XBMCK_SYSREQ;
+/*
+    s_keysymTable[SDLK_CANCEL] = XBMCK_CANCEL;
+*/
+    s_keysymTable[SDLK_CLEAR] = XBMCK_CLEAR;
+/*
+    s_keysymTable[SDLK_PRIOR] = XBMCK_PRIOR;
+    s_keysymTable[SDLK_RETURN2] = XBMCK_RETURN2;
+    s_keysymTable[SDLK_SEPARATOR] = XBMCK_SEPARATOR;
+    s_keysymTable[SDLK_OUT] = XBMCK_OUT;
+    s_keysymTable[SDLK_OPER] = XBMCK_OPER;
+    s_keysymTable[SDLK_CLEARAGAIN] = XBMCK_CLEARAGAIN;
+    s_keysymTable[SDLK_CRSEL] = XBMCK_CRSEL;
+    s_keysymTable[SDLK_EXSEL] = XBMCK_EXSEL;
+    s_keysymTable[SDLK_KP_00] = XBMCK_KP_00;
+    s_keysymTable[SDLK_KP_000] = XBMCK_KP_000;
+    s_keysymTable[SDLK_THOUSANDSSEPARATOR] = XBMCK_THOUSANDSSEPARATOR;
+    s_keysymTable[SDLK_DECIMALSEPARATOR] = XBMCK_DECIMALSEPARATOR;
+    s_keysymTable[SDLK_CURRENCYUNIT] = XBMCK_CURRENCYUNIT;
+    s_keysymTable[SDLK_CURRENCYSUBUNIT] = XBMCK_CURRENCYSUBUNIT;
+    s_keysymTable[SDLK_KP_LEFTPAREN] = XBMCK_KP_LEFTPAREN;
+    s_keysymTable[SDLK_KP_RIGHTPAREN] = XBMCK_KP_RIGHTPAREN;
+    s_keysymTable[SDLK_KP_LEFTBRACE] = XBMCK_KP_LEFTBRACE;
+    s_keysymTable[SDLK_KP_RIGHTBRACE] = XBMCK_KP_RIGHTBRACE;
+    s_keysymTable[SDLK_KP_TAB] = XBMCK_KP_TAB;
+    s_keysymTable[SDLK_KP_BACKSPACE] = XBMCK_KP_BACKSPACE;
+    s_keysymTable[SDLK_KP_A] = XBMCK_KP_A;
+    s_keysymTable[SDLK_KP_B] = XBMCK_KP_B;
+    s_keysymTable[SDLK_KP_C] = XBMCK_KP_C;
+    s_keysymTable[SDLK_KP_D] = XBMCK_KP_D;
+    s_keysymTable[SDLK_KP_E] = XBMCK_KP_E;
+    s_keysymTable[SDLK_KP_F] = XBMCK_KP_F;
+    s_keysymTable[SDLK_KP_XOR] = XBMCK_KP_XOR;
+    s_keysymTable[SDLK_KP_POWER] = XBMCK_KP_POWER;
+    s_keysymTable[SDLK_KP_PERCENT] = XBMCK_KP_PERCENT;
+    s_keysymTable[SDLK_KP_LESS] = XBMCK_KP_LESS;
+    s_keysymTable[SDLK_KP_GREATER] = XBMCK_KP_GREATER;
+    s_keysymTable[SDLK_KP_AMPERSAND] = XBMCK_KP_AMPERSAND;
+    s_keysymTable[SDLK_KP_DBLAMPERSAND] = XBMCK_KP_DBLAMPERSAND;
+    s_keysymTable[SDLK_KP_VERTICALBAR] = XBMCK_KP_VERTICALBAR;
+    s_keysymTable[SDLK_KP_DBLVERTICALBAR] = XBMCK_KP_DBLVERTICALBAR;
+    s_keysymTable[SDLK_KP_COLON] = XBMCK_KP_COLON;
+    s_keysymTable[SDLK_KP_HASH] = XBMCK_KP_HASH;
+    s_keysymTable[SDLK_KP_SPACE] = XBMCK_KP_SPACE;
+    s_keysymTable[SDLK_KP_AT] = XBMCK_KP_AT;
+    s_keysymTable[SDLK_KP_EXCLAM] = XBMCK_KP_EXCLAM;
+    s_keysymTable[SDLK_KP_MEMSTORE] = XBMCK_KP_MEMSTORE;
+    s_keysymTable[SDLK_KP_MEMRECALL] = XBMCK_KP_MEMRECALL;
+    s_keysymTable[SDLK_KP_MEMCLEAR] = XBMCK_KP_MEMCLEAR;
+    s_keysymTable[SDLK_KP_MEMADD] = XBMCK_KP_MEMADD;
+    s_keysymTable[SDLK_KP_MEMSUBTRACT] = XBMCK_KP_MEMSUBTRACT;
+    s_keysymTable[SDLK_KP_MEMMULTIPLY] = XBMCK_KP_MEMMULTIPLY;
+    s_keysymTable[SDLK_KP_MEMDIVIDE] = XBMCK_KP_MEMDIVIDE;
+    s_keysymTable[SDLK_KP_PLUSMINUS] = XBMCK_KP_PLUSMINUS;
+    s_keysymTable[SDLK_KP_CLEAR] = XBMCK_KP_CLEAR;
+    s_keysymTable[SDLK_KP_CLEARENTRY] = XBMCK_KP_CLEARENTRY;
+    s_keysymTable[SDLK_KP_BINARY] = XBMCK_KP_BINARY;
+    s_keysymTable[SDLK_KP_OCTAL] = XBMCK_KP_OCTAL;
+    s_keysymTable[SDLK_KP_DECIMAL] = XBMCK_KP_DECIMAL;
+    s_keysymTable[SDLK_KP_HEXADECIMAL] = XBMCK_KP_HEXADECIMAL;
+*/
+    s_keysymTable[SDLK_LCTRL] = XBMCK_LCTRL;
+    s_keysymTable[SDLK_LSHIFT] = XBMCK_LSHIFT;
+    s_keysymTable[SDLK_LALT] = XBMCK_LALT;
+    s_keysymTable[SDLK_LGUI] = XBMCK_LSUPER;
+    s_keysymTable[SDLK_RCTRL] = XBMCK_RCTRL;
+    s_keysymTable[SDLK_RSHIFT] = XBMCK_RSHIFT;
+    s_keysymTable[SDLK_RALT] = XBMCK_RALT;
+    s_keysymTable[SDLK_RGUI] = XBMCK_RSUPER;
+    s_keysymTable[SDLK_MODE] = XBMCK_MODE;
+    s_keysymTable[SDLK_AUDIONEXT] = XBMCK_MEDIA_NEXT_TRACK;
+    s_keysymTable[SDLK_AUDIOPREV] = XBMCK_MEDIA_PREV_TRACK;
+    s_keysymTable[SDLK_AUDIOSTOP] = XBMCK_MEDIA_STOP;
+    s_keysymTable[SDLK_AUDIOPLAY] = XBMCK_MEDIA_PLAY_PAUSE;
+    s_keysymTable[SDLK_AUDIOMUTE] = XBMCK_VOLUME_MUTE;
+    s_keysymTable[SDLK_MEDIASELECT] = XBMCK_LAUNCH_MEDIA_SELECT;
+    s_keysymTable[SDLK_WWW] = XBMCK_BROWSER_HOME;
+    s_keysymTable[SDLK_MAIL] = XBMCK_LAUNCH_MAIL;
+    s_keysymTable[SDLK_CALCULATOR] = XBMCK_LAUNCH_APP1;
+    s_keysymTable[SDLK_COMPUTER] = XBMCK_LAUNCH_FILE_BROWSER;
+    s_keysymTable[SDLK_AC_SEARCH] = XBMCK_BROWSER_SEARCH;
+    s_keysymTable[SDLK_AC_HOME] = XBMCK_BROWSER_HOME;
+    s_keysymTable[SDLK_AC_BACK] = XBMCK_BROWSER_BACK;
+    s_keysymTable[SDLK_AC_FORWARD] = XBMCK_BROWSER_FORWARD;
+    s_keysymTable[SDLK_AC_STOP] = XBMCK_BROWSER_STOP;
+    s_keysymTable[SDLK_AC_REFRESH] = XBMCK_BROWSER_REFRESH;
+    s_keysymTable[SDLK_AC_BOOKMARKS] = XBMCK_BROWSER_FAVORITES;
+/*
+    s_keysymTable[SDLK_BRIGHTNESSDOWN] = XBMCK_BRIGHTNESSDOWN;
+    s_keysymTable[SDLK_BRIGHTNESSUP] = XBMCK_BRIGHTNESSUP;
+    s_keysymTable[SDLK_DISPLAYSWITCH] = XBMCK_DISPLAYSWITCH;
+    s_keysymTable[SDLK_KBDILLUMTOGGLE] = XBMCK_KBDILLUMTOGGLE;
+    s_keysymTable[SDLK_KBDILLUMDOWN] = XBMCK_KBDILLUMDOWN;
+    s_keysymTable[SDLK_KBDILLUMUP] = XBMCK_KBDILLUMUP;
+*/
+    s_keysymTable[SDLK_EJECT] = XBMCK_EJECT;
+    s_keysymTable[SDLK_SLEEP] = XBMCK_SLEEP;
+}
+
+static XBMCKey LookupKeysym(SDL_Keycode keycode)
+{
+	if (s_keysymTable.size() == 0) {
+		InitializeKeysymLookup();
+	}
+
+	std::map<SDL_Keycode, XBMCKey>::iterator it = s_keysymTable.find(keycode);
+	if (it != s_keysymTable.end()) {
+		return it->second;
+	}
+	return XBMCK_UNKNOWN;
+}
+
+#endif // SDL 2.0
+
 bool CWinEventsSDL::MessagePump()
 {
   SDL_Event event;
@@ -229,6 +499,7 @@ bool CWinEventsSDL::MessagePump()
           CApplicationMessenger::GetInstance().PostMsg(TMSG_QUIT);
         break;
 
+#if HAVE_SDL_VERSION == 1
       case SDL_ACTIVEEVENT:
         //If the window was inconified or restored
         if( event.active.state & SDL_APPACTIVE )
@@ -270,7 +541,7 @@ bool CWinEventsSDL::MessagePump()
           mod |= XBMCKMOD_LSUPER;
         newEvent.key.keysym.mod = (XBMCMod) mod;
 
-#if defined(TARGET_POSIX) && !defined(TARGET_DARWIN)
+#ifdef HAVE_X11
         // If the keysym.sym is zero try to get it from the scan code
         if (newEvent.key.keysym.sym == 0)
           newEvent.key.keysym.sym = (XBMCKey) SymFromScancode(newEvent.key.keysym.scancode);
@@ -353,6 +624,7 @@ bool CWinEventsSDL::MessagePump()
         ret |= g_application.OnEvent(newEvent);
         break;
       }
+
       case SDL_VIDEORESIZE:
       {
         // Under newer osx versions sdl is so fucked up that it even fires resize events
@@ -372,6 +644,140 @@ bool CWinEventsSDL::MessagePump()
         g_windowManager.MarkDirty();
         break;
       }
+
+      case SDL_VIDEOEXPOSE:
+      {
+        g_windowManager.MarkDirty();
+        break;
+      }
+#endif // SDL 1.2
+
+#if HAVE_SDL_VERSION == 2
+      case SDL_WINDOWEVENT:
+      {
+        switch( event.window.event )
+        {
+        case SDL_WINDOWEVENT_MINIMIZED:
+          if (g_application.GetRenderGUI())
+          {
+            g_application.SetRenderGUI(false);
+            g_Windowing.NotifyAppActiveChange(g_application.GetRenderGUI());
+          }
+          break;
+        case SDL_WINDOWEVENT_RESTORED:
+          if (!g_application.GetRenderGUI())
+          {
+            g_application.SetRenderGUI(true);
+            g_Windowing.NotifyAppActiveChange(g_application.GetRenderGUI());
+          }
+          break;
+        case SDL_WINDOWEVENT_FOCUS_GAINED:
+          g_application.m_AppFocused = true;
+          g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+          break;
+        case SDL_WINDOWEVENT_FOCUS_LOST:
+          g_application.m_AppFocused = false;
+          g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+          break;
+        }
+        break;
+      }
+
+      case SDL_KEYDOWN:
+      {
+        // process any platform specific shortcuts before handing off to XBMC
+#ifdef TARGET_DARWIN_OSX
+        if (ProcessOSXShortcuts(event))
+        {
+          ret = true;
+          break;
+        }
+#endif
+
+        XBMC_Event newEvent;
+        newEvent.type = XBMC_KEYDOWN;
+        newEvent.key.keysym.scancode = event.key.keysym.scancode;
+        newEvent.key.keysym.sym = LookupKeysym(event.key.keysym.sym);
+        newEvent.key.keysym.unicode = 0;
+        newEvent.key.state = event.key.state;
+
+        // Check if the Windows keys are down because SDL doesn't flag this.
+        uint16_t mod = event.key.keysym.mod;
+        const uint8_t* keystate = SDL_GetKeyboardState(NULL);
+        if (keystate[SDL_SCANCODE_LGUI] || keystate[SDL_SCANCODE_RGUI])
+          mod |= XBMCKMOD_LSUPER;
+        newEvent.key.keysym.mod = (XBMCMod) mod;
+
+#ifdef HAVE_X11
+        // If the keysym.sym is zero try to get it from the scan code
+        if (newEvent.key.keysym.sym == 0)
+          newEvent.key.keysym.sym = (XBMCKey) SymFromScancode(newEvent.key.keysym.scancode);
+#endif
+
+        // don't handle any more messages in the queue until we've handled keydown,
+        // if a keyup is in the queue it will reset the keypress before it is handled.
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case SDL_KEYUP:
+      {
+        XBMC_Event newEvent;
+        newEvent.type = XBMC_KEYUP;
+        newEvent.key.keysym.scancode = event.key.keysym.scancode;
+        newEvent.key.keysym.sym = LookupKeysym(event.key.keysym.sym);
+        newEvent.key.keysym.mod =(XBMCMod) event.key.keysym.mod;
+        newEvent.key.keysym.unicode = 0;
+        newEvent.key.state = event.key.state;
+
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case SDL_MOUSEBUTTONDOWN:
+      {
+        XBMC_Event newEvent;
+        newEvent.type = XBMC_MOUSEBUTTONDOWN;
+        newEvent.button.button = event.button.button;
+        newEvent.button.state = event.button.state;
+        newEvent.button.which = event.button.which;
+        newEvent.button.x = event.button.x;
+        newEvent.button.y = event.button.y;
+
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case SDL_MOUSEBUTTONUP:
+      {
+        XBMC_Event newEvent;
+        newEvent.type = XBMC_MOUSEBUTTONUP;
+        newEvent.button.button = event.button.button;
+        newEvent.button.state = event.button.state;
+        newEvent.button.which = event.button.which;
+        newEvent.button.x = event.button.x;
+        newEvent.button.y = event.button.y;
+
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case SDL_MOUSEMOTION:
+      {
+        XBMC_Event newEvent;
+        newEvent.type = XBMC_MOUSEMOTION;
+        newEvent.motion.xrel = event.motion.xrel;
+        newEvent.motion.yrel = event.motion.yrel;
+        newEvent.motion.state = event.motion.state;
+        newEvent.motion.which = event.motion.which;
+        newEvent.motion.x = event.motion.x;
+        newEvent.motion.y = event.motion.y;
+
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+#endif // SDL 2.0
+
       case SDL_USEREVENT:
       {
         XBMC_Event newEvent;
@@ -380,9 +786,6 @@ bool CWinEventsSDL::MessagePump()
         ret |= g_application.OnEvent(newEvent);
         break;
       }
-      case SDL_VIDEOEXPOSE:
-        g_windowManager.MarkDirty();
-        break;
     }
     memset(&event, 0, sizeof(SDL_Event));
   }
@@ -392,11 +795,16 @@ bool CWinEventsSDL::MessagePump()
 
 size_t CWinEventsSDL::GetQueueSize()
 {
-  int ret;
-  SDL_Event event;
+  int ret = 0;
 
-  if (-1 == (ret = SDL_PeepEvents(&event, 0, SDL_PEEKEVENT, ~0)))
+#if HAVE_SDL_VERSION == 1
+  if (-1 == (ret = SDL_PeepEvents(NULL, 0, SDL_PEEKEVENT, ~0)))
     ret = 0;
+#endif
+#if HAVE_SDL_VERSION == 2
+  if (-1 == (ret = SDL_PeepEvents(NULL, 0, SDL_PEEKEVENT, SDL_FIRSTEVENT, SDL_LASTEVENT)))
+    ret = 0;
+#endif
 
   return ret;
 }
diff --git a/xbmc/windowing/WinEventsSDL.h b/xbmc/windowing/WinEventsSDL.h
index 6a23658..154e588 100644
--- a/xbmc/windowing/WinEventsSDL.h
+++ b/xbmc/windowing/WinEventsSDL.h
@@ -28,7 +28,7 @@
 #if HAVE_SDL_VERSION == 1
 #include <SDL/SDL_events.h>
 #elif HAVE_SDL_VERSION == 2
-#include <SDL/SDL_events.h>
+#include <SDL2/SDL_events.h>
 #endif
 
 #include "WinEvents.h"
diff --git a/xbmc/windowing/egl/EGLNativeTypeSDL.cpp b/xbmc/windowing/egl/EGLNativeTypeSDL.cpp
new file mode 100644
index 0000000..d3523cb
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeSDL.cpp
@@ -0,0 +1,161 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+
+#include "EGLNativeTypeSDL.h"
+#include "guilib/gui3d.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+
+#if HAVE_SDL_VERSION == 2
+
+CEGLNativeTypeSDL::CEGLNativeTypeSDL()
+{
+  m_window = NULL;
+
+  if (SDL_InitSubSystem(SDL_INIT_VIDEO) < 0) {
+    return;
+  }
+
+  SDL_DisplayMode mode;
+  SDL_GetDesktopDisplayMode(0, &mode);
+
+  m_window = SDL_CreateWindow("SDL", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, mode.w, mode.h, SDL_WINDOW_FULLSCREEN|SDL_WINDOW_HIDDEN);
+  if (!m_window) {
+    return;
+  }
+
+  SDL_VERSION(&m_windowInfo.version);
+  if (SDL_GetWindowWMInfo(m_window, &m_windowInfo) < 0 || m_windowInfo.subsystem != SDL_SYSWM_VIVANTE) {
+    SDL_DestroyWindow(m_window);
+    m_window = NULL;
+  }
+
+  // XBMC draws its own cursor
+  SDL_ShowCursor(0);
+}
+
+CEGLNativeTypeSDL::~CEGLNativeTypeSDL()
+{
+  if (m_window) {
+    SDL_DestroyWindow(m_window);
+  }
+  SDL_QuitSubSystem(SDL_INIT_VIDEO);
+} 
+
+bool CEGLNativeTypeSDL::CheckCompatibility()
+{
+  return (m_window != NULL);
+}
+
+void CEGLNativeTypeSDL::Initialize()
+{
+}
+
+void CEGLNativeTypeSDL::Destroy()
+{
+}
+
+bool CEGLNativeTypeSDL::CreateNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeSDL::CreateNativeWindow()
+{
+  SDL_ShowWindow(m_window);
+  return true;
+}
+
+bool CEGLNativeTypeSDL::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)
+    return false;
+  *nativeDisplay = (XBNativeDisplayType*) &m_windowInfo.info.vivante.display;
+  return true;
+}
+
+bool CEGLNativeTypeSDL::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  if (!nativeWindow)
+    return false;
+  *nativeWindow = (XBNativeWindowType*) &m_windowInfo.info.vivante.window;
+  return true;
+}  
+
+bool CEGLNativeTypeSDL::DestroyNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeSDL::DestroyNativeWindow()
+{
+  SDL_HideWindow(m_window);
+  return true;
+}
+
+bool CEGLNativeTypeSDL::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  SDL_GetWindowSize(m_window, &res->iWidth, &res->iHeight);
+  res->fRefreshRate = 59.94f;
+  res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  res->iScreen = 0;
+  res->bFullScreen = true;
+  res->iSubtitles = static_cast<int>(0.965 * res->iHeight);
+  res->fPixelRatio = 1.0f;
+  res->iScreenWidth = res->iWidth;
+  res->iScreenHeight = res->iHeight;
+  res->strMode = StringUtils::Format("%dx%d @ %.2fp",
+                     res->iScreenWidth,
+                     res->iScreenHeight,
+                     res->fRefreshRate);
+  return true;
+}
+
+bool CEGLNativeTypeSDL::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  return true;
+}
+
+bool CEGLNativeTypeSDL::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  RESOLUTION_INFO res;
+  if (!GetNativeResolution(&res))
+    return false;
+
+  resolutions.push_back(res);
+  return true;
+}
+
+bool CEGLNativeTypeSDL::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  return GetNativeResolution(res);
+}
+
+bool CEGLNativeTypeSDL::ShowWindow(bool show)
+{
+  if (show)
+    SDL_ShowWindow(m_window);
+  else
+    SDL_HideWindow(m_window);
+  return true;
+}
+
+#endif // SDL 2.0
diff --git a/xbmc/windowing/egl/EGLNativeTypeSDL.h b/xbmc/windowing/egl/EGLNativeTypeSDL.h
new file mode 100644
index 0000000..387a848
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeSDL.h
@@ -0,0 +1,60 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if HAVE_SDL_VERSION == 2
+
+#include "EGLNativeType.h"
+#include "SDL2/SDL.h"
+#include "SDL2/SDL_syswm.h"
+
+class CEGLNativeTypeSDL : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeSDL();
+  virtual ~CEGLNativeTypeSDL();
+  virtual std::string GetNativeName() const { return "SDL"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+
+private:
+  SDL_Window *m_window;
+  SDL_SysWMinfo m_windowInfo;
+};
+
+#endif // SDL 2.0
diff --git a/xbmc/windowing/egl/EGLWrapper.cpp b/xbmc/windowing/egl/EGLWrapper.cpp
index 30f5757..6422bfb 100644
--- a/xbmc/windowing/egl/EGLWrapper.cpp
+++ b/xbmc/windowing/egl/EGLWrapper.cpp
@@ -37,6 +37,9 @@
 #if defined(TARGET_LINUX) && defined(HAS_LIBAMCODEC)
 #include "EGLNativeTypeAmlogic.h"
 #endif
+#if HAVE_SDL_VERSION == 2
+#include "EGLNativeTypeSDL.h"
+#endif
 #include "EGLWrapper.h"
 
 #define CheckError() m_result = eglGetError(); if(m_result != EGL_SUCCESS) CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, m_result);
@@ -101,6 +104,8 @@ bool CEGLWrapper::Initialize(const std::string &implementation)
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeIMX>(implementation))
 #elif defined(TARGET_LINUX) && defined(HAS_LIBAMCODEC)
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeAmlogic>(implementation))
+#elif HAVE_SDL_VERSION == 2
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeSDL>(implementation))
 #endif
       )
   {
diff --git a/xbmc/windowing/egl/Makefile.in b/xbmc/windowing/egl/Makefile.in
index 68f7862..02a3ba5 100644
--- a/xbmc/windowing/egl/Makefile.in
+++ b/xbmc/windowing/egl/Makefile.in
@@ -1,6 +1,7 @@
 INCLUDES=-I.
 
 SRCS = WinSystemEGL.cpp
+SRCS+= EGLNativeTypeSDL.cpp
 SRCS+= EGLNativeTypeAmlogic.cpp
 ifeq (@USE_ANDROID@,1)
 SRCS+= EGLNativeTypeAndroid.cpp
-- 
2.7.4

